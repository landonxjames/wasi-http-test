use serde_json;
//This macro generates Rust types from the .wit file and identifies the structs
//to export for use in the WASM module. The cargo expand tool can be helpful to
//see the code generated by this macro
wit_bindgen::generate!({
world: "wasm-version-tests",
exports: {
    "wasm-version-tests:component/clients/wasm-version-tests-client": WasmVersionTestsClients,
    "wasm-version-tests:component/events/wasm-version-tests-event": WasmVersionTestsEvents,
},
// additional_derives: [serde::Serialize, serde::Deserialize]
});
use exports::wasm_version_tests::component::clients::GuestWasmVersionTestsClient;
use exports::wasm_version_tests::component::events::GuestWasmVersionTestsEvent;
use wasi::http::outgoing_handler::handle;
use wasi::http::types::{
    ErrorCode, Fields, FutureIncomingResponse, IncomingBody, IncomingResponse, OutgoingRequest,
    RequestOptions, Scheme,
};

//Impl the traits from your .wit file on these structs
pub struct WasmVersionTestsClients;
pub struct WasmVersionTestsEvents;

impl GuestWasmVersionTestsClient for WasmVersionTestsClients {
    fn hello_world(&self) -> String {
        println!("TESTING STDOUT");
        return "Hello World".to_string();
    }

    fn new() -> Self {
        WasmVersionTestsClients
    }
}

impl GuestWasmVersionTestsEvent for WasmVersionTestsEvents {
    fn parse(&self, input: String) -> Result<IncomingResponse, ErrorCode> {
        let headers = Fields::from_list(&vec![]).unwrap();
        let req = OutgoingRequest::new(headers);
        let auth_set = req.set_authority(Some("httpbin.org"));
        match auth_set {
            Ok(e) => {
                println!("SET AUTH OK");
            }
            Err(e) => {
                println!("SET AUTH ERROR");
            }
        }
        req.set_path_with_query(Some("/get"));
        req.set_scheme(Some(&Scheme::Https));
        println!("REQUEST:",);
        println!("AUTHORITY: {:?}", req.authority());
        println!("PATH: {:?}", req.path_with_query());
        println!("SCHEME: {:?}", req.scheme());

        let sent_req = handle(req, None);
        let inc_resp = sent_req.unwrap();
        let sub_req = inc_resp.subscribe();
        sub_req.block();
        let ready_req = sub_req.ready();
        println!("REQ READY: {}", ready_req);

        let final_resp = inc_resp.get().unwrap().unwrap().unwrap();
        let body = final_resp.consume().unwrap();
        let body_stream = body.stream().unwrap();
        let mut full_bytes: Vec<u8> = Vec::new();
        while let Ok(mut stream_bytes) = body_stream.blocking_read(u64::MAX) {
            full_bytes.append(stream_bytes.as_mut())
        }
        println!("BODY BYTES: {:?}", full_bytes);
        println!("BODY STR: {:#?}", std::str::from_utf8(&full_bytes).unwrap());

        // let body_fut = IncomingBody::finish(body);
        // let body_fut_sub = body_fut.subscribe();
        // body_fut_sub.block();
        // let body = body_fut.get();
        // println!("THE BODY: {:#?}", body);
        //.finish().subscribe().block()
        Ok(final_resp)
    }

    fn new() -> Self {
        WasmVersionTestsEvents
    }
}

// use cargo_component;
// cargo_component::cargo_component_bindings::generate!();

// use bindings::Guest;

// struct Component;

// impl Guest for Component {
//     /// Say hello!
//     fn hello_world() -> String {
//         "Hello, World!".to_string()
//     }
// }
