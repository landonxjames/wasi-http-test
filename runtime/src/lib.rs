use serde_json;
//This macro generates Rust types from the .wit file and identifies the structs
//to export for use in the WASM module. The cargo expand tool can be helpful to
//see the code generated by this macro
wit_bindgen::generate!({
world: "wasi-http-tests",
exports: {
    "wasi-http-tests:component/client/wasi-http-tests-client": WasiHttpTestsClient,
},
// additional_derives: [serde::Serialize, serde::Deserialize]
});
use exports::wasi_http_tests::component::client::GuestWasiHttpTestsClient;
use wasi::http::outgoing_handler::handle;
use wasi::http::types::{
    ErrorCode, Fields, FutureIncomingResponse, IncomingBody, IncomingResponse, OutgoingRequest,
    RequestOptions, Scheme,
};

//Impl the traits from your .wit file on these structs
pub struct WasiHttpTestsClient;

impl GuestWasiHttpTestsClient for WasiHttpTestsClient {
    fn http_call(&self) -> Result<String, String> {
        //Below section is building the http request and then printing it
        let headers = Fields::from_list(&vec![]).map_err(|e| e.to_string())?;
        let req = OutgoingRequest::new(headers);
        req.set_authority(Some("httpbin.org"));
        req.set_path_with_query(Some("/get"));
        req.set_scheme(Some(&Scheme::Https));
        println!("REQUEST:",);
        println!("AUTHORITY: {:?}", req.authority());
        println!("PATH: {:?}", req.path_with_query());
        println!("SCHEME: {:?}", req.scheme());

        //Send the http request
        let inc_resp = handle(req, None).map_err(|e| e.to_string())?;
        //We subscribe to a pollable of the FutureIncomingResponse and then block
        //waiting for it to resolve
        let sub_req = inc_resp.subscribe();
        sub_req.block();
        //Don't actually need to check this since we blocked waiting for it,
        //just confirming for testing
        let ready_req = sub_req.ready();
        println!("REQ READY: {}", ready_req);

        //This is pretty ugly because the FutureIncomingResponse .get() method returns a
        //Option<Result<Result<IncomingResponse, ErrorCode>, ()>>.
        //The outer Option is the readiness which we know is Some because we .block() waiting for it
        //The outer Result is just a singleton enforcer so we can only get the response once
        //The inner Result indicates whether the HTTP call was sent/received successfully (not the 200 succes of the call)
        let final_resp = inc_resp
            .get()
            .unwrap()
            .unwrap()
            .map_err(|e| e.to_string())?;

        //Extracting the body of the response
        let body = final_resp.consume().unwrap();
        let body_stream = body.stream().unwrap();

        //TODO: could potentially check the content-length header value to set
        //the length dynamically if its less than u64::MAX (it should be). This
        //would probably save some time by allocing the correct vec size from
        //the start
        //Vec to hold the body
        let mut full_bytes: Vec<u8> = Vec::new();
        //Loop to extract the bytes from the stream until it is empty
        while let Ok(mut stream_bytes) = body_stream.blocking_read(u64::MAX) {
            full_bytes.append(stream_bytes.as_mut())
        }
        //Printing the raw bytes and the utf8 string of the body
        println!("BODY BYTES: {:?}", full_bytes);
        let body_string = std::str::from_utf8(&full_bytes).unwrap();
        println!("BODY STR: {:#?}", body_string);

        Ok(body_string.to_string())
    }

    fn new() -> Self {
        WasiHttpTestsClient
    }
}
